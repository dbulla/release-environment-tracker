/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.nurflugel.releasetracker

import org.springframework.jdbc.core.JdbcTemplate
import java.awt.Toolkit
import java.awt.datatransfer.DataFlavor.stringFlavor
import java.lang.management.ManagementFactory
import java.time.LocalDateTime

class ParserApp() {

  fun run(jdbcTemplate: JdbcTemplate) {

    val runtimeMxBean = ManagementFactory.getRuntimeMXBean()
    val jvmArguments = runtimeMxBean.inputArguments.filter { it.startsWith("-X") }

    if (jvmArguments.isNotEmpty()) println("JVM arguments: $jvmArguments")
    val textToProcess = getClipboardContents()
    if (textToProcess != null) {
      val newData: List<DataRecord> = parseData(textToProcess)
      saveData(newData, jdbcTemplate)
    } else {
      println("No data found in buffer to process")
    }
  }

  private fun saveData(newData: List<DataRecord>, jdbcTemplate: JdbcTemplate) {
    println("newData size: ${newData.size}")
    for (datum in newData) {
      var date = datum.date
      if (date == null) {
        date = LocalDateTime.now()
      }
      // todo move into stored procedure
      val sql = ("""
              INSERT INTO deploys (app_name, build_number, author, commit_message, deploy_date, environment, story, version, commit_hash)
              VALUES ('${datum.appName}','${datum.buildNumber}', '${datum.author}','${datum.commitMessage}','$date','${datum.deployEnvironment}','${datum.story}','${datum.version}', '${datum.commitHash}')
              ON CONFLICT (app_name, build_number, environment) DO UPDATE
                 SET deploy_date = excluded.deploy_date,
                     commit_message = excluded.commit_message,
                     commit_hash = excluded.commit_hash,
                     story = excluded.story;
                """).trimIndent();
      try {
        jdbcTemplate.update(sql)
        println("Saved ${datum.appName}, build# ${datum.buildNumber}, author: ${datum.author}, message: ${datum.commitMessage}, hash: ${datum.commitHash}")
      } catch (e: Exception) {
        println("e.message = ${e.message}")
      }
    }
  }

  /** Take the text copy/pasted text and parse the data we want out of it */
  private fun parseData(textToProcess: String): List<DataRecord> {
    val lines = textToProcess.split('\n')
    return lines
      .filter { it.startsWith("app:") }
      .filter { !it.startsWith("app: dibble") }
      .map { DataRecord(it) }
  }

  private fun getClipboardContents(): String? {
    println("getClipboardContents()")
    val clipboard = Toolkit.getDefaultToolkit().systemClipboard
    val contents = clipboard.getContents(null)
    val hasTransferableText = contents != null && contents.isDataFlavorSupported(stringFlavor)
    if (hasTransferableText) {
      try {
        return contents!!.getTransferData(stringFlavor) as String
      } catch (e: Exception) {
        println(e)
        e.printStackTrace()
      }
    }
    return null
  }
}
